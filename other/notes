- converting unity to godot transform:
	- move decimal right 2 times i.e. x100. e.g. 0.75 = 75.0
	- reverse negative number on y axis e.g. 1.25 = -1.25

- minimap unity values:
	- minimap camera:
		- follows player
		- zoomed out more than standard player camera by 1.5x
		- minimap viewport size: 270x270px
	- circular mask used for viewport to make it circular
- boss encounters implementation notes:
	- quest export
		- should allow boss encounters to hold optional quests that revolve slaying the boss itself
	- quest prerequisite:
		- quest that must be finished in order to gain access to boss encounter
	- quests should be saved in files like the enemies/party_members for ease of use (most games save quests in files e.g. monster hunter frontier)
	- boss rewards
		- armour & weapons
	- how original game handles quest rewards:
		- no gold or xp is given upon completing any of the quests
		- 1 weapon & 1 armour per party member is given to the party upon entering the boss battle
			- realistically, quest gear should be given when said quest is marked as finished
	- flip original boss sprites horizontally
		- done so that they could be properly used as party members

- inventory system implementation ideas:
	- implementation #1:
		- item resource:
			- items inherit base item resource
			- base item props:
				- name
				- stack_size: defaults to 1 for gear compat
				- amount: (1-stack_size)
					- if amount = 0, the item should be removed from player inventory
				- signals:
					- on_remove:
						- when item stack_size reaches 0
					- on_amount_changed:
						- when item is either dropped/aquired/sold. anyway that amount is changed
					- aquired:
						- when item is added to player's inventory
			- different custom resources types:
				- consumable: stack size defaults to 15, item effect/action e.g. heal party
					- effect func should have a target entity/list of entities as parameter
					- effect func can alter entity stats in a positive/negative way
				- gear: stats, stack_size = 1
					- stats: can hold a stat of defence, attack, etc.
						- maybe use combat_stats resource
						- up to combat scene how entity gear stats affect combat e.g. only use attack
					- entity type/class that can equip:
						- e.g. only warrior can equip plate armour
						- armour/weapon select screen should sort by party member like in original
		- inventory autoload:
			- this will manage player inventory: add/remove/use item, stacks, etc.
			- a dict or array, holding custom item resources
			- signals:
				- on_item_added(item)
					- when new item is added to player's inventory
		- gui item:
			- button that is used to display item name and count to the player in the camp menu
			- clicking on the button performs the item's action if consumable
		- camp_menu:
			- item inventory fetches player inventory from inventory autoload, updates ui list of items
		- item management flow example:
			- player buys a potion from the item shop
			- potion is added to the player's inventory
			- inventory manager emit's signal on_item_added
			- gui inventory in party camp recieves the signal
			- gui item scene is instantiated
			- gui item scene connects item's on_amount_changed and other stat changing signals
			- gui inventory connects item's on_remove signal
	- implementation #2:
		- same item resource as before
		- each item has a unique id
		- stored in an item database dict
			- dict(id, item_resource)
		- gui inventory fetches the list of items in the player's inventory and displays them
			- try to handle it from another thread
	- gui_inventory should have filter options to filter items by type
		- could be used to only display items of x type in one gui_inventory without needing to have an inventory for armour & a seperate one for weapons

- original shop implementation notes:
	- 4 shop scenes (+ summary of differences):
		- armour shop: shopkeeper text, options(buy, exit), inventory
		- weapon shop: shopkeeper text, options(buy, exit), inventory
		- item shop: shopkeeper text, options(buy, sell, exit), inventory
		- revive shop: shopkeeper text, options(dynamic list of dead party members)
	- each shop follows the same structure with less/more features
	- generic shop:
		- title at the top
		- shopkeeper text box to the left
			- text changes based on state:
				- welcome state
				- buy state
				- purchased state
				- declined state
					- declined state text also triggers on sale specifically in item shop
		- shop options box at the bottom
			- buy option
				- changes shopkeeper text
				- hides shop options box
			- exit
				- exits shop back to town scene
		- big shop inventory panel to the right
			- clicking items without entering buy state still works (bug or qol?)
			- this exists in every shop except for revive shop
		- revive shop
			- same panels, different logic as the generic shop
			- shop options box lists dead party members
			- clicking party member member prompts yes or no
				- prompt simply replaces all choices from options box with yes and no text boxes
			- if yes clicked, member revived
			- if no, return to previous state
			- shopkeeper displayed 2 messages
				- no revival needed
				- revival available
			- revival price is not displayed
			- cannot exit revive if revive is available (bug)
				- only way to leave is to revive party member (costs 40g)
				- could potentially cause a soft lock if player gil < 40
		- armour and weapon shops:
			- identical, differing only in inventory
			- bought weapon/armour is not added into any party member's inventory (bug)
		- item shop:
			- same as armour/weapon shop with key differences:
				- ability to sell items
					- brings up player inventory, clicking items sells them instead of using them
						- sell price: item value / 2.0

- item use function:
	- part of base item class
	- parameter: list of entity_properties objects
	- returns: integer success code ( 0=pass, 1=fail)
	- base use: print item description
	- used for:
		- using items e.g. potion to heal party member(s)
		- equip weapon on party member
		- party member(s) take dmg, gain/lose gold, lose items, etc.
			- whacky!

- damage formula:
	- reduction: attack / 100 * (target_def * target_def_muliplier)
	- total_attack: attack + weapon_attack
	- final: total_attack - reduction (clamped at 1/0?)
	- full formula: attack + weapon_attack - (attack / 100 * (target_def * target_def_muliplier))

- transitions:
	- better off to have to two locales per transition point:
		- origin and target locales
		- target locale takes you to the next map
		- origin locale stores data of map that the transition point is located in e.g. desert map
		- previous locale is used to store the origin locale when moving to the target locale, so that we can move back to the previous locale with ease
		- if target locale = null, go back to previous locale
	- need to support mutliple entrance locations to the same locale e.g.
		multiple towns in desert map should lead to same town scene and back to
		different position on the desert map
	- current solution:
		- locale data: name, entrance pos, and scene file
		- go to scene and update player position to entrance pos
	- maybe?
		- track name of locale player is entering
		- use dict of locales when exiting, match the name of the previous locale
		- if locales dict == 1, no need to match locales

- combat system:
	- ui:
		- interface:
			- needs:
				- gold reward
				- xp reward
				- current entity name
				- current entity damage
				- target name
			- solutions:
				- add actions and target reference to generic_entity script
				- create on_turn_end(entity) signal
				- connect signal to combat interface
		- party stats box:
			- needs:
				- member health
				- member name
				- member xp
				- member required xp
			- solutions:
				- add entity_properties reference
				- connect party stats box to party member stats signals:
					- hp changed
					- xp changed

- map transition system (door system?) maybe??
	- door class/scene:
		- holds scene to load
		- holds position of player to store, that is the position of the player before the door
	- autoload manager that stores previous door used

- the player should not be a child of any of the maps (town, desert)
	- player should not be destroyed when switching maps

- general code refactor:
	- rename all load/preload vars to PascalCase
	- fix instructions board

- saving system:
	- what to save:
		- party members:
			- name
			- combat stats
		- inventory:
			- items:
				- count
			- weapons:
				- upgrade level
				- damage
			- armor:
				- upgrade level
				- defence
		- overworld:
			- current scene (either town or desert)
			- position
	- when choosing new game:
		- create party and append each member to party manager
	- when choosing continue game:
		- check if save file present
		- load from file if save file present
		- add members to party manager
	- how to save:
		- first, remove the current scene
		- load in the singleton saved items e.g. items, party
		- then, load map data
	- when the game is actually saved:
		- when opening the camp menu
		- when leaving the combat scene

- party system:
	- base combat entity class (name = combat_stats)
		- create entity resource that holds all necessary stats
			- hp/max hp
			- damage
			- defense
			- xp/required xp
			- level
			- stat scalars
				- hp, damage, required xp, etc.
			- weapon (extra damage)
			- armour (extra defense)
	- create an entity scene for each combat entity in the game
		- party members:
			- fighter
			- mage
			- thief
			- black belt
		- enemies:
			- Snail
			- Cactus
			- Bandit
			- DesertWarrior
			- DesertShinobi
			- DarkShinobi
			- ShadeShinobi
		- bosses
			- BossBoss
			- BossSpy
			- BossMan
			- BossWalk
			- BossBossBoss
			- BossWif
		- combat scene will have an enemy spawn table, with percent chance to spawn each enemy
